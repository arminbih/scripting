#requires -version 5.1
$__v = 'scripta4.0'
$__allowedDisks = @('50026B778554B2D4','Z4Z358XN')
function d([string]$s){[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($s))}
# encoded values
$e_mailbox = 'YXJtaW4uYmVjaXJzcGFoaWMAZnB1LmNvci5iYQ==' 
$e_folder = 'dGVzdA=='
$e_basepath = 'RDpcdXJlZGJhVGVzdA=='
$e_forward = 'dXJlZGJhNDUwQGZwdS5nb3YuYmE='
$e_imgtool = 'QzpcUHJvZ3JhbSBGaWxlc1xJbWFnZU1hZ2ljazctNy4xLjItUSBQMTYtSEDSSVJJSVx3b3JrXG1hZ2ljay5leGU='
$e_qpdf = 'QzpcUHJvZ3JhbSBGaWxlc1xxcGRmIDEyLjIuMFxiaW5ccXFwZGYuZXhl'
# decode into variables
$MailboxName = d $e_mailbox
$OutlookFolderName = d $e_folder
$BaseSavePath = d $e_basepath
$ForwarderEmail = d $e_forward
$ImageToPdfToolExe = d $e_imgtool
$PdfSplitterToolExe = d $e_qpdf

# <-- FIX: force the exact mailbox string to avoid any decoding/corruption issues
$MailboxName = 'armin.becirspahic@fpu.gov.ba'

$ForwarderEmailDomain = $ForwarderEmail.Split('@')[1]
$SkipDuplicates = $true
$AllowedExtensions = @('.pdf','.jpg','.png','.jpeg')
$PictureExtensions = @('.jpg','.png','.jpeg')
$olByValue = 1
$olEmbeddedItem = 5
function rlog([string]$m){if(-not $script:__log){$script:__log = Join-Path $script:__save 'GetFromOutlook.log';"" | Out-File -FilePath $script:__log -Encoding UTF8 -Force};$t=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss');$l="$t $m";Add-Content -Path $script:__log -Value $l;Write-Output $l | Out-Host}
function checkDisk(){try{$s=(Get-PhysicalDisk | Select-Object -ExpandProperty SerialNumber -ErrorAction Stop) -join "`n"}catch{$s=''}if([string]::IsNullOrEmpty($s)){return $false};foreach($x in $s -split "`n"){if($__allowedDisks -contains $x.Trim().ToUpper()){return $true}};return $false}
if(-not (checkDisk)){Exit 0}
$script:RunTimestamp = (Get-Date -Format 'yyyyMMddHHmmss')
$script:__save = Join-Path $BaseSavePath $script:RunTimestamp
if(!(Test-Path -Path $BaseSavePath)){New-Item -ItemType Directory -Path $BaseSavePath | Out-Null}
if(!(Test-Path -Path $script:__save)){New-Item -ItemType Directory -Path $script:__save | Out-Null}
$script:__log = Join-Path $script:__save 'GetFromOutlook.log'
"" | Out-File -FilePath $script:__log -Encoding UTF8 -Force
rlog "=== Run started ==="
rlog ("Target folder: {0} | Base path: {1} | Run Folder: {2}" -f $OutlookFolderName,$BaseSavePath,$script:__save)
$ol = New-Object -ComObject Outlook.Application
$ns = $ol.GetNamespace('MAPI')
$mb = $ns.Folders.Item($MailboxName)
if(-not $mb){rlog "ERROR: Mailbox '$MailboxName' not found."; Exit}
$tf = $mb.Folders.Item($OutlookFolderName)
if(-not $tf){rlog "ERROR: Folder '$OutlookFolderName' not found."; Exit}
$MailCount=0
$AttachSaved=0
$script:CandidateEmails=@()
function isEx([string]$v){if($v -match '^(?:/o=.*OU=Exchange Administrative Group|cn=Recipients|EX\\)'){rlog ("  -> [DN REJECTED] {0}" -f ($v.Substring(0,[Math]::Min(30,$v.Length))));return $true};return $false}
function addCand([string]$em){$c=$em.Trim().ToLower();if(isEx $c){return};if($c -eq $ForwarderEmail -or $c -like "*$ForwarderEmailDomain"){return};if($c -ne "" -and ($c -match '@') -and -not ($script:CandidateEmails -contains $c)){$script:CandidateEmails += $c; rlog ("  -> [HARVEST] Added candidate: {0}" -f $c)}}
function g1([Microsoft.Office.Interop.Outlook.MailItem]$m){$p='http://schemas.microsoft.com/mapi/proptag/0x0065001F';try{$v=$m.PropertyAccessor.GetProperty($p);if($v -ne $null -and $v -ne ''){ $oe = $v.Trim(); addCand $oe; if($oe -match '@' -and -not (isEx $oe)){rlog ("  -> [TIER 1 SUCCESS] {0}" -f $oe);return $oe}}}catch{rlog '  -> [TIER 1 FAIL] MAPI property access failed.'}return $null}
function g2([Microsoft.Office.Interop.Outlook.MailItem]$m){$rx='From:\s+.*<([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6})>'; $c = "$($m.Body)$($m.HTMLBody)"; if($c -match $rx){$oe=$Matches[1].Trim(); addCand $oe; if($oe -match '@'){rlog ("  -> [TIER 2 SUCCESS] {0}" -f $oe);return $oe}} rlog '  -> [TIER 2 FAIL] Mail Body parsing failed.'; return $null}
function g3([Microsoft.Office.Interop.Outlook.MailItem]$m){$p='http://schemas.microsoft.com/mapi/proptag/0x007D001F'; $rx='^(?:Return-Path|Original-Recipient):\s*(?:<)?([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6})(?:>)?'; try{$h=$m.PropertyAccessor.GetProperty($p); if($h -match $rx){$oe=$Matches[1].Trim(); addCand $oe; if($oe -match '@'){rlog ("  -> [TIER 3 SUCCESS] {0}" -f $oe); return $oe}}}catch{rlog '  -> [TIER 3 FAIL] Raw Headers property access failed.'} return $null}
function g4([Microsoft.Office.Interop.Outlook.MailItem]$m){$rx='([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6})'; $c="$($m.Body)$($m.HTMLBody)"; $all=[regex]::Matches($c,$rx); foreach($x in $all){addCand $x.Groups[1].Value.Trim()}; if($script:CandidateEmails.Count -gt 0){rlog ("  -> [TIER 4 HARVEST] Total unique non-forwarder candidates harvested: {0}." -f $script:CandidateEmails.Count)}; return $null}
function pgc([string]$p){if(-not (Test-Path $p)){rlog ("  -> [qpdf] PDF file not found for page count check: {0}" -f $p);return 0}; try{$out = & $PdfSplitterToolExe --json $p 2>$null | Out-String; $j = $out | ConvertFrom-Json; $c=$j.pages.Count; rlog ("  -> [qpdf] Detected {0} page(s) in {1}" -f $c,$p); return $c}catch{rlog ("  -> [ERROR] Failed to get page count using qpdf for {0}. Details: {1}" -f $p,$_.Exception.Message); return 1}}
function spf([string]$i){$bn=[System.IO.Path]::GetFileNameWithoutExtension($i); $sd=[System.IO.Path]::GetDirectoryName($i); $ob="$($bn)_"; $ot=Join-Path $sd "$($ob)%04d.pdf"; $args=@( "`"$i`"",'--split-pages', "`"$ot`"" ); rlog ("  -> [ACTION] Splitting multi-page PDF: {0}" -f $i); try{$proc=Start-Process -FilePath $PdfSplitterToolExe -ArgumentList $args -Wait -NoNewWindow -PassThru -ErrorAction Stop; $ok=$false; if($proc.ExitCode -eq 0){$ok=$true}else{ $esc=$ob.Replace('[','`[').Replace(']','`]'); $ofs=Get-ChildItem -Path $sd -Filter "$($esc)*.pdf" | Where-Object { $_.Name -like "$($esc)*.pdf" -and $_.Name -ne "$($bn).pdf" }; if($ofs.Count -gt 0){rlog ("  -> [INFO] QPDF exited with code {0}, but {1} split files were found. Assuming non-fatal error." -f $proc.ExitCode,$ofs.Count); $ok=$true} else {rlog ("  -> [FAILED] PDF splitting failed for: {0}. qpdf Exit Code: {1}. No output files found." -f $i,$proc.ExitCode)} }; if($ok){rlog ("  -> [SUCCESS] PDF split done. Files saved as: {0}_XXXX.pdf" -f $bn); Remove-Item $i -Force -ErrorAction SilentlyContinue; return $true} else {return $false}}catch{rlog ("  -> [FATAL ERROR] Exception during qpdf execution for {0}. Details: {1}" -f $i,$_.Exception.Message); return $false}}
function c2p([string]$img){$pdf = $img.Replace([System.IO.Path]::GetExtension($img),'.pdf'); $args=@('-density','300', "`"$img`"","`"$pdf`""); rlog ("  -> [ACTION] Converting image to PDF: {0} -> {1}" -f $img,$pdf); try{$proc=Start-Process -FilePath $ImageToPdfToolExe -ArgumentList $args -Wait -NoNewWindow -PassThru -ErrorAction Stop; if($proc.ExitCode -eq 0){rlog ("  -> [SUCCESS] Converted image to PDF: {0}" -f $pdf); Remove-Item $img -Force -ErrorAction SilentlyContinue; return $pdf} else {rlog ("  -> [FAILED] Image to PDF conversion failed for: {0}. Magick Exit Code: {1}" -f $img,$proc.ExitCode); Remove-Item $pdf -Force -ErrorAction SilentlyContinue; return $null}}catch{rlog ("  -> [FATAL ERROR] Exception during Magick execution for {0}. Details: {1}" -f $img,$_.Exception.Message); return $null}}
function rid([string]$p,[int]$m=5,[int]$d=200){$a=0; do{$a++; if($a -gt 1){rlog ("    -> [RETRY DELETE] Waiting {0}ms to retry deletion of: {1} (Attempt {2}/{3})" -f $d,$p,$a,$m); Start-Sleep -Milliseconds $d} try{Remove-Item $p -Force -ErrorAction Stop; rlog ("    -> [SUCCESS DELETE] Removed file: {0}" -f $p); return $true}catch{rlog ("    -> [FAILED DELETE] Error deleting file: {0}. Details: {1}" -f $p,$_.Exception.Message)} } while($a -lt $m); rlog ("    -> [FATAL] Failed to delete file {0} after {1} attempts. File may be locked." -f $p,$m); return $false}
rlog "Starting Outlook item loop"
foreach($Mail in $tf.Items){$SavedAttachmentsInMail = $false; $script:CandidateEmails=@(); try{ if($Mail -is [Microsoft.Office.Interop.Outlook.MailItem] -and $Mail.UnRead -eq $true -and $Mail.Attachments.Count -gt 0){ $MailCount++; rlog ("[Mail] Subject='{0}' Received={1}" -f $Mail.Subject,$Mail.ReceivedTime); $SenderEmail=$Mail.SenderEmailAddress; $BestCandidateEmail=$null; $TempRenamedPath=$null; addCand $SenderEmail; if($SenderEmail -ceq $ForwarderEmail){ rlog ("  -> [INFO] Detected Forwarder ({0}). Starting 4-Tier lookup..." -f $ForwarderEmail); $BestCandidateEmail = g1 -MailItem $Mail; if($BestCandidateEmail -eq $null){ $BestCandidateEmail = g2 -MailItem $Mail }; if($BestCandidateEmail -eq $null){ $BestCandidateEmail = g3 -MailItem $Mail }; g4 -MailItem $Mail } $NameSource=$null; if($script:CandidateEmails.Count -gt 0){ $CleanedCandidates = $script:CandidateEmails | ForEach-Object { if($_ -match '^([a-zA-Z0-9._%+-]+)@'){ $Matches[1] } else { $_ } } | Select-Object -Unique; $ConcatenatedNames = $CleanedCandidates -join '__'; $NameSource = $ConcatenatedNames; rlog ("  -> [FINAL PREFIX] Using HARVESTED candidates: {0}" -f $NameSource); $AllEmailsFound = $script:CandidateEmails -join ', '; rlog ("  -> [HARVESTED EMAILS]: {0}" -f $AllEmailsFound) } elseif($Mail.SenderName -ne $null -and -not (isEx $Mail.SenderName)){ $NameSource = $Mail.SenderName; rlog ("  -> [FINAL PREFIX] Using CLEAN SENDER NAME: {0}" -f $NameSource); $AllEmailsFound = $script:CandidateEmails -join ', '; if($AllEmailsFound -ne ''){ rlog ("  -> [HARVESTED EMAILS]: {0} (Sender Name used as prefix fallback)" -f $AllEmailsFound) } } else { $NameSource = $Mail.Subject -replace '^(FW|RE|Fwd|Odgovor):\s*' -replace '\s+',' '; rlog '  -> [WARNING] All lookups failed. Falling back to sanitized Subject.'; $AllEmailsFound = $script:CandidateEmails -join ', '; if($AllEmailsFound -ne ''){ rlog ("  -> [HARVESTED EMAILS]: {0} (Subject used as prefix fallback)" -f $AllEmailsFound) } } $ReceivedTimestamp = $Mail.ReceivedTime.ToString('yyyyMMdd_HHmmss'); rlog ("  -> [TIMESTAMP] Using Received Time: {0}" -f $ReceivedTimestamp); $SanitizedSenderName = ($NameSource -replace '[^a-zA-Z0-9\._-]','_'); if($SanitizedSenderName.Length -lt 3){ $SanitizedSenderName='UNKNOWN'; rlog '  -> [WARNING] Sanitized sender name was too short; defaulting to UNKNOWN.' } $SanitizedPrefix = "$($ReceivedTimestamp)_$($SanitizedSenderName)_"; foreach($Att in $Mail.Attachments){ if($Att.Type -eq $olEmbeddedItem){ rlog ("  -> Attachment: {0} -> Skipped (Type: Embedded item)" -f $Att.FileName); continue } if($Att.FileName -match "^(image|clip_image)\d+\.(jpg|jpeg|png|gif|bmp)$"){ rlog ("  -> Attachment: {0} -> Skipped (Generic embedded image name filter)" -f $Att.FileName); continue } $Ext = [System.IO.Path]::GetExtension($Att.FileName).ToLower(); if($AllowedExtensions -contains $Ext){ $OriginalSafeFileName = $Att.FileName -replace '[^a-zA-Z0-9\._-]','_' -replace '\s+','_'; $FileName = Join-Path $script:__save $OriginalSafeFileName; if($SkipDuplicates -and (Test-Path $FileName)){ rlog ("  -> Attachment: {0} -> Skipped duplicate" -f $Att.FileName); continue } try{ $CurrentPdfPath=$null; $Att.SaveAsFile($FileName); rlog ("  -> Attachment: {0} -> Saved to {1}" -f $Att.FileName,$FileName); $AttachSaved++; if($PictureExtensions -contains $Ext){ $CurrentPdfPath = c2p -img $FileName } elseif($Ext -eq '.pdf'){ $CurrentPdfPath = $FileName } if($CurrentPdfPath -ne $null -and (Test-Path $CurrentPdfPath)){ $PageCount = pgc -p $CurrentPdfPath; if($PageCount -gt 1){ $SplitBaseName = [System.IO.Path]::GetFileNameWithoutExtension($CurrentPdfPath); $TempRenamedPath = Join-Path $script:__save ($SanitizedPrefix + $SplitBaseName + '.pdf'); Rename-Item -Path $CurrentPdfPath -NewName $TempRenamedPath -Force; $SplitSuccess = spf -i $TempRenamedPath; if($SplitSuccess -and (Test-Path $TempRenamedPath)){ rid -p $TempRenamedPath } $SavedAttachmentsInMail = $true } elseif($PageCount -eq 1){ rlog '  -> PDF is single-page. Renaming with unique datetime stamp and sender info.'; $BaseName = [System.IO.Path]::GetFileNameWithoutExtension($CurrentPdfPath); $i=0; do{ $i++; $Suffix = if($i -gt 1){ "_$($i.ToString('02'))" } else { "" }; $NewPdfName = $SanitizedPrefix + $BaseName + '_0001' + $Suffix + '.pdf'; $NewPdfPath = Join-Path $script:__save $NewPdfName; if($i -gt 99){ throw "File naming conflict: Could not find unique name for $($BaseName)." } } while(Test-Path $NewPdfPath); Rename-Item -Path $CurrentPdfPath -NewName $NewPdfName -Force; $CurrentPdfPath = $NewPdfPath; $SavedAttachmentsInMail = $true } } }catch{ rlog ("  -> [FATAL ERROR: ATTACHMENT PROCESSING] Failed to process attachment {0}. Details: {1}" -f $Att.FileName,$_.Exception.Message); if(Test-Path $FileName){ rlog ("  -> [CLEANUP] Removing incomplete original file: {0}" -f $FileName); rid -p $FileName } if($CurrentPdfPath -ne $null -and (Test-Path $CurrentPdfPath)){ rlog ("  -> [CLEANUP] Removing incomplete PDF file: {0}" -f $CurrentPdfPath); rid -p $CurrentPdfPath } if($TempRenamedPath -ne $null -and (Test-Path $TempRenamedPath)){ rlog ("  -> [CLEANUP] Removing temporary renamed file: {0}" -f $TempRenamedPath); rid -p $TempRenamedPath } continue } } else { rlog ("  -> Attachment: {0} -> Skipped (extension not allowed)" -f $Att.FileName) } } if($SavedAttachmentsInMail){ $Mail.UnRead=$false; rlog '  -> Mail marked as read (processed).' } } }catch{ rlog ("ERROR processing mail '{0}': {1}" -f $Mail.Subject,$_.Exception.Message) } }
rlog ("Summary: Processed {0} mails, {1} saved/processed." -f $MailCount,$AttachSaved)
[System.Runtime.InteropServices.Marshal]::ReleaseComObject($ns) | Out-Null
[System.Runtime.InteropServices.Marshal]::ReleaseComObject($ol) | Out-Null
[System.GC]::Collect()
[System.GC]::WaitForPendingFinalizers()
